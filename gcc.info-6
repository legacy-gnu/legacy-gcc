This is Info file gcc.info, produced by Makeinfo-1.44 from the input
file gcc.texi.

   This file documents the use and the internals of the GNU compiler.

   Copyright (C) 1988, 1989, 1992 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" and this permission notice may be included in translations
approved by the Free Software Foundation instead of in the original
English.


File: gcc.info,  Node: Bug Reporting,  Next: Non-bugs,  Prev: Bug Criteria,  Up: Bugs

How to Report Bugs
==================

   Send bug reports for GNU C to one of these addresses:

     bug-gcc@prep.ai.mit.edu
     {ucbvax|mit-eddie|uunet}!prep.ai.mit.edu!bug-gcc

   *Do not send bug reports to `help-gcc', or to the newsgroup
`gnu.gcc.help'.* Most users of GNU CC do not want to receive bug
reports.  Those that do, have asked to be on `bug-gcc'.

   The mailing list `bug-gcc' has a newsgroup which serves as a
repeater.  The mailing list and the newsgroup carry exactly the same
messages.  Often people think of posting bug reports to the newsgroup
instead of mailing them.  This appears to work, but it has one problem
which can be crucial: a newsgroup posting does not contain a mail path
back to the sender.  Thus, if I need to ask for more information, I
may be unable to reach you.  For this reason, it is better to send bug
reports to the mailing list.

   As a last resort, send bug reports on paper to:

     GNU Compiler Bugs
     Free Software Foundation
     675 Mass Ave
     Cambridge, MA 02139

   The fundamental principle of reporting bugs usefully is this:
*report all the facts*.  If you are not sure whether to state a fact
or leave it out, state it!

   Often people omit facts because they think they know what causes the
problem and they conclude that some details don't matter.  Thus, you
might assume that the name of the variable you use in an example does
not matter.  Well, probably it doesn't, but one cannot be sure. 
Perhaps the bug is a stray memory reference which happens to fetch
from the location where that name is stored in memory; perhaps, if the
name were different, the contents of that location would fool the
compiler into doing the right thing despite the bug.  Play it safe and
give a specific, complete example.  That is the easiest thing for you
to do, and the most helpful.

   Keep in mind that the purpose of a bug report is to enable me to fix
the bug if it is not known.  It isn't very important what happens if
the bug is already known.  Therefore, always write your bug reports on
the assumption that the bug is not known.

   Sometimes people give a few sketchy facts and ask, "Does this ring a
bell?"  Those bug reports are useless, and I urge everyone to *refuse
to respond to them* except to chide the sender to report bugs properly.

   To enable me to fix the bug, you should include all these things:

   * The version of GNU CC.  You can get this by running it with the
     `-v' option.

     Without this, I won't know whether there is any point in looking
     for the bug in the current version of GNU CC.

   * A complete input file that will reproduce the bug.  If the bug is
     in the C preprocessor, send me a source file and any header files
     that it requires.  If the bug is in the compiler proper (`cc1'),
     run your source file through the C preprocessor by doing `gcc -E
     SOURCEFILE > OUTFILE', then include the contents of OUTFILE in
     the bug report.  (Any `-I', `-D' or `-U' options that you used in
     actual compilation should also be used when doing this.)

     A single statement is not enough of an example.  In order to
     compile it, it must be embedded in a function definition; and the
     bug might depend on the details of how this is done.

     Without a real example I can compile, all I can do about your bug
     report is wish you luck.  It would be futile to try to guess how
     to provoke the bug.  For example, bugs in register allocation and
     reloading frequently depend on every little detail of the function
     they happen in.

   * The command arguments you gave GNU CC to compile that example and
     observe the bug.  For example, did you use `-O'?  To guarantee
     you won't omit something important, list them all.

     If I were to try to guess the arguments, I would probably guess
     wrong and then I would not encounter the bug.

   * The type of machine you are using, and the operating system name
     and version number.

   * The operands you gave to the `configure' command when you
     installed the compiler.

   * A description of what behavior you observe that you believe is
     incorrect.  For example, "It gets a fatal signal," or, "There is
     an incorrect assembler instruction in the output."

     Of course, if the bug is that the compiler gets a fatal signal,
     then I will certainly notice it.  But if the bug is incorrect
     output, I might not notice unless it is glaringly wrong.  I won't
     study all the assembler code from a 50-line C program just on the
     off chance that it might be wrong.

     Even if the problem you experience is a fatal signal, you should
     still say so explicitly.  Suppose something strange is going on,
     such as, your copy of the compiler is out of synch, or you have
     encountered a bug in the C library on your system.  (This has
     happened!)  Your copy might crash and mine would not.  If you
     told me to expect a crash, then when mine fails to crash, I would
     know that the bug was not happening for me.  If you had not told
     me to expect a crash, then I would not be able to draw any
     conclusion from my observations.

     Often the observed symptom is incorrect output when your program
     is run.  Sad to say, this is not enough information for me unless
     the program is short and simple.  If you send me a large program,
     I don't have time to figure out how it would work if compiled
     correctly, much less which line of it was compiled wrong.  So you
     will have to do that.  Tell me which source line it is, and what
     incorrect result happens when that line is executed.  A person
     who understands the program can find this as easily as a bug in
     the program itself.

   * If you send me examples of output from GNU CC, please use `-g'
     when you make them.  The debugging information includes source
     line numbers which are essential for correlating the output with
     the input.

   * If you wish to suggest changes to the GNU CC source, send me
     context diffs.  If you even discuss something in the GNU CC
     source, refer to it by context, not by line number.

     The line numbers in my development sources don't match those in
     your sources.  Your line numbers would convey no useful
     information to me.

   * Additional information from a debugger might enable me to find a
     problem on a machine which I do not have available myself. 
     However, you need to think when you collect this information if
     you want it to have any chance of being useful.

     For example, many people send just a backtrace, but that is never
     useful by itself.  A simple backtrace with arguments conveys
     little about GNU CC because the compiler is largely data-driven;
     the same functions are called over and over for different RTL
     insns, doing different things depending on the details of the
     insn.

     Most of the arguments listed in the backtrace are useless because
     they are pointers to RTL list structure.  The numeric values of
     the pointers, which the debugger prints in the backtrace, have no
     significance whatever; all that matters is the contents of the
     objects they point to (and most of the contents are other such
     pointers).

     In addition, most compiler passes consist of one or more loops
     that scan the RTL insn sequence.  The most vital piece of
     information about such a loop--which insn it has reached--is
     usually in a local variable, not in an argument.

     What you need to provide in addition to a backtrace are the
     values of the local variables for several stack frames up.  When
     a local variable or an argument is an RTX, first print its value
     and then use the GDB command `pr' to print the RTL expression
     that it points to.  (If GDB doesn't run on your machine, use your
     debugger to call the function `debug_rtx' with the RTX as an
     argument.)  In general, whenever a variable is a pointer, its
     value is no use without the data it points to.

     In addition, include a debugging dump from just before the pass
     in which the crash happens.  Most bugs involve a series of insns,
     not just one.

   Here are some things that are not necessary:

   * A description of the envelope of the bug.

     Often people who encounter a bug spend a lot of time investigating
     which changes to the input file will make the bug go away and
     which changes will not affect it.

     This is often time consuming and not very useful, because the way
     I will find the bug is by running a single example under the
     debugger with breakpoints, not by pure deduction from a series of
     examples.  I recommend that you save your time for something else.

     Of course, if you can find a simpler example to report *instead*
     of the original one, that is a convenience for me.  Errors in the
     output will be easier to spot, running under the debugger will
     take less time, etc.  Most GNU CC bugs involve just one function,
     so the most straightforward way to simplify an example is to
     delete all the function definitions except the one where the bug
     occurs.  Those earlier in the file may be replaced by external
     declarations if the crucial function depends on them. 
     (Exception: inline functions may affect compilation of functions
     defined later in the file.)

     However, simplification is not vital; if you don't want to do
     this, report the bug anyway and send me the entire test case you
     used.

   * A patch for the bug.

     A patch for the bug does help me if it is a good one.  But don't
     omit the necessary information, such as the test case, on the
     assumption that a patch is all I need.  I might see problems with
     your patch and decide to fix the problem another way, or I might
     not understand it at all.

     Sometimes with a program as complicated as GNU CC it is very hard
     to construct an example that will make the program follow a
     certain path through the code.  If you don't send me the example,
     I won't be able to construct one, so I won't be able to verify
     that the bug is fixed.

     And if I can't understand what bug you are trying to fix, or why
     your patch should be an improvement, I won't install it.  A test
     case will help me to understand.

   * A guess about what the bug is or what it depends on.

     Such guesses are usually wrong.  Even I can't guess right about
     such things without first using the debugger to find the facts.


File: gcc.info,  Node: Non-bugs,  Prev: Bug Reporting,  Up: Bugs

Certain Changes We Don't Want to Make
=====================================

   This section lists changes that people frequently request, but which
we do not make because we think GNU CC is better without them.

   * Checking the number and type of arguments to a function which has
     an old-fashioned definition and no prototype.

     Such a feature would work only occasionally--only for calls that
     appear in the same file as the called function, following the
     definition.  The only way to check all calls reliably is to add a
     prototype for the function.  But adding a prototype eliminates
     the motivation for this feature.  So the feature is not
     worthwhile.

   * Warning about using an expression whose type is signed as a shift
     count.

     Shift count operands are probably signed more often than unsigned. 
     Warning about this would cause far more annoyance than good.

   * Warning about assigning a signed value to an unsigned variable.

     Such assignments must be very common; warning about them would
     cause more annoyance than good.

   * Warning when a non-void function value is ignored.

     Coming as I do from a Lisp background, I balk at the idea that
     there is something dangerous about discarding a value.  There are
     functions that return values which some callers may find useful;
     it makes no sense to clutter the program with a cast to `void'
     whenever the value isn't useful.

   * Making bitfields unsigned by default on particular machines where
     "the ABI standard" says to do so.

     The ANSI C standard leaves it up to the implementation whether a
     bitfield declared plain `int' is signed or not.  This in effect
     creates two alternative dialects of C.

     The GNU C compiler supports both dialects; you can specify the
     dialect you want with the option `-fsigned-bitfields' or
     `-funsigned-bitfields'.  However, this leaves open the question
     of which dialect to use by default.

     Currently, the preferred dialect makes plain bitfields signed,
     because this is simplest.  Since `int' is the same as `signed
     int' in every other context, it is cleanest for them to be the
     same in bitfields as well.

     Some computer manufacturers have published Application Binary
     Interface standards which specify that plain bitfields should be
     unsigned.  It is a mistake, however, to say anything about this
     issue in an ABI.  This is because the handling of plain bitfields
     distinguishes two dialects of C.  Both dialects are meaningful on
     every type of machine.  Whether a particular object file was
     compiled using signed bitfields or unsigned is of no concern to
     other object files, even if they access the same bitfields in the
     same data structures.

     A given program is written in one or the other of these two
     dialects.  The program stands a chance to work on most any
     machine if it is compiled with the proper dialect.  It is
     unlikely to work at all if compiled with the wrong dialect.

     Many users appreciate the GNU C compiler because it provides an
     environment that is uniform across machines.  These users would be
     inconvenienced if the compiler treated plain bitfields
     differently on certain machines.

     Occasionally users write programs intended only for a particular
     machine type.  On these occasions, the users would benefit if the
     GNU C compiler were to support by default the same dialect as the
     other compilers on that machine.  But such applications are rare.
      And users writing a program to run on more than one type of
     machine cannot possibly benefit from this kind of compatibility.

     This is why GNU CC does and will treat plain bitfields in the same
     fashion on all types of machines (by default).

     There are some arguments for making bitfields unsigned by default
     on all machines.  If, for example, this becomes a universal de
     facto standard, it would make sense for GNU CC to go along with
     it.  This is something to be considered in the future.

     (Of course, users strongly concerned about portability should
     indicate explicitly in each bitfield whether it is signed or not.
      In this way, they write programs which have the same meaning in
     both C dialects.)

   * Undefining `__STDC__' when `-ansi' is not used.

     Currently, GNU CC defines `__STDC__' as long as you don't use
     `-traditional'.  This provides good results in practice.

     Programmers normally use conditionals on `__STDC__' to ask whether
     it is safe to use certain features of ANSI C, such as function
     prototypes or ANSI token concatenation.  Since plain `gcc'
     supports all the features of ANSI C, the correct answer to these
     questions is "yes".

     Some users try to use `__STDC__' to check for the availability of
     certain library facilities.  This is actually incorrect usage in
     an ANSI C program, because the ANSI C standard says that a
     conforming freestanding implementation should define `__STDC__'
     even though it does not have the library facilities.  `gcc -ansi
     -pedantic' is a conforming freestanding implementation, and it is
     therefore required to define `__STDC__', even though it does not
     come with an ANSI C library.

     Sometimes people say that defining `__STDC__' in a compiler that
     does not completely conform to the ANSI C standard somehow
     violates the standard.  This is illogical.  The standard is a
     standard for compilers that claim to support ANSI C, such as `gcc
     -ansi'--not for other compilers such as plain `gcc'.  Whatever
     the ANSI C standard says is relevant to the design of plain `gcc'
     without `-ansi' only for pragmatic reasons, not as a requirement.

   * Undefining `__STDC__' in C++.

     Programs written to compile with C++-to-C translators get the
     value of `__STDC__' that goes with the C compiler that is
     subsequently used.  These programs must test `__STDC__' to
     determine what kind of C preprocessor that compiler uses: whether
     they should concatenate tokens in the ANSI C fashion or in the
     traditional fashion.

     These programs work properly with GNU C++ if `__STDC__' is
     defined.  They would not work otherwise.

     In addition, many header files are written to provide prototypes
     in ANSI C but not in traditional C.  Many of these header files
     can work without change in C++ provided `__STDC__' is defined. 
     If `__STDC__' is not defined, they will all fail, and will all
     need to be changed to test explicitly for C++ as well.


File: gcc.info,  Node: VMS,  Next: Portability,  Prev: Bugs,  Up: Top

Using GNU CC on VMS
*******************

* Menu:

* Include Files and VMS::  Where the preprocessor looks for the include files.
* Global Declarations::    How to do globaldef, globalref and globalvalue with
                           GNU CC.
* VMS Misc::		   Misc information.


File: gcc.info,  Node: Include Files and VMS,  Next: Global Declarations,  Prev: VMS,  Up: VMS

Include Files and VMS
=====================

   Due to the differences between the filesystems of Unix and VMS, GNU
CC attempts to translate file names in `#include' into names that VMS
will understand.  The basic strategy is to prepend a prefix to the
specification of the include file, convert the whole filename to a VMS
filename, and then try to open the file.  GNU CC tries various prefixes
one by one until one of them succeeds:

  1. The first prefix is the `GNU_CC_INCLUDE:' logical name: this is
     where GNU C header files are traditionally stored.  If you wish
     to store header files in non-standard locations, then you can
     assign the logical `GNU_CC_INCLUDE' to be a search list, where
     each element of the list is suitable for use with a rooted
     logical.

  2. The next prefix tried is `SYS$SYSROOT:[SYSLIB.]'.  This is where
     VAX-C header files are traditionally stored.

  3. If the include file specification by itself is a valid VMS
     filename, the preprocessor then uses this name with no prefix in
     an attempt to open the include file.

  4. If the file specification is not a valid VMS filename (i.e. does
     not contain a device or a directory specifier, and contains a `/'
     character), the preprocessor tries to convert it from Unix syntax
     to VMS syntax.

        Conversion works like this: the first directory name becomes a
     device, and the rest of the directories are converted into
     VMS-format directory names.  For example, `X11/foobar.h' is
     translated to `X11:[000000]foobar.h' or `X11:foobar.h', whichever
     one can be opened.  This strategy allows you to assign a logical
     name to point to the actual location of the header files.

  5. If none of these strategies succeeds, the `#include' fails.

   Include directives of the form:

     #include foobar

are a common source of incompatibility between VAX-C and GNU CC.  VAX-C
treats this much like a standard `#include <foobar.h>' directive. 
That is incompatible with the ANSI C behavior implemented by GNU CC: to
expand the name `foobar' as a macro.  Macro expansion should
eventually yield one of the two standard formats for `#include':

     #include "FILE"
     #include <FILE>

   If you have this problem, the best solution is to modify the source
to convert the `#include' directives to one of the two standard forms. 
That will work with either compiler.  If you want a quick and dirty
fix, define the file names as macros with the proper expansion, like
this:

     #define stdio <stdio.h>

This will work, as long as the name doesn't conflict with anything else
in the program.

   Another source of incompatibility is that VAX-C assumes that:

     #include "foobar"

is actually asking for the file `foobar.h'.  GNU CC does not make this
assumption, and instead takes what you ask for literally; it tries to
read the file `foobar'.  The best way to avoid this problem is to
always specify the desired file extension in your include directives.

   GNU CC for VMS is distributed with a set of include files that is
sufficient to compile most general purpose programs.  Even though the
GNU CC distribution does not contain header files to define constants
and structures for some VMS system-specific functions, there is no
reason why you cannot use GNU CC with any of these functions.  You
first may have to generate or create header files, either by using the
public domain utility `UNSDL' (which can be found on a DECUS tape), or
by extracting the relevant modules from one of the system macro
libraries, and using an editor to construct a C header file.


File: gcc.info,  Node: Global Declarations,  Next: VMS Misc,  Prev: Include Files and VMS,  Up: VMS

Global Declarations and VMS
===========================

   GNU CC does not provide the `globalref', `globaldef' and
`globalvalue' keywords of VAX-C.  You can get the same effect with an
obscure feature of GAS, the GNU assembler.  (This requires GAS version
1.39 or later.)  The following macros allow you to use this feature in
a fairly natural way:

     #ifdef __GNUC__
     #define GLOBALREF(TYPE,NAME)                      \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME)
     #define GLOBALDEF(TYPE,NAME,VALUE)                \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME) \
         = VALUE
     #define GLOBALVALUEREF(TYPE,NAME)                 \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE)           \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)  \
         = {VALUE}
     #else
     #define GLOBALREF(TYPE,NAME) \
       globalref TYPE NAME
     #define GLOBALDEF(TYPE,NAME,VALUE) \
       globaldef TYPE NAME = VALUE
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE) \
       globalvalue TYPE NAME = VALUE
     #define GLOBALVALUEREF(TYPE,NAME) \
       globalvalue TYPE NAME
     #endif

(The `_$$PsectAttributes_GLOBALSYMBOL' prefix at the start of the name
is removed by the assembler, after it has modified the attributes of
the symbol).  These macros are provided in the VMS binaries
distribution in a header file `GNU_HACKS.H'.  An example of the usage
is:

     GLOBALREF (int, ijk);
     GLOBALDEF (int, jkl, 0);

   The macros `GLOBALREF' and `GLOBALDEF' cannot be used
straightforwardly for arrays, since there is no way to insert the array
dimension into the declaration at the right place.  However, you can
declare an array with these macros if you first define a typedef for
the array type, like this:

     typedef int intvector[10];
     GLOBALREF (intvector, foo);

   Array and structure initializers will also break the macros; you can
define the initializer to be a macro of its own, or you can expand the
`GLOBALDEF' macro by hand.  You may find a case where you wish to use
the `GLOBALDEF' macro with a large array, but you are not interested
in explicitly initializing each element of the array.  In such cases
you can use an initializer like: `{0,}', which will initialize the
entire array to `0'.

   A shortcoming of this implementation is that a variable declared
with `GLOBALVALUEREF' or `GLOBALVALUEDEF' is always an array.  For
example, the declaration:

     GLOBALVALUEREF(int, ijk);

declares the variable `ijk' as an array of type `int [1]'.  This is
done because a globalvalue is actually a constant; its "value" is what
the linker would normally consider an address.  That is not how an
integer value works in C, but it is how an array works.  So treating
the symbol as an array name gives consistent results--with the
exception that the value seems to have the wrong type.  *Don't try to
access an element of the array.*  It doesn't have any elements.  The
array "address" may not be the address of actual storage.

   The fact that the symbol is an array may lead to warnings where the
variable is used.  Insert type casts to avoid the warnings.  Here is an
example; it takes advantage of the ANSI C feature allowing macros that
expand to use the same name as the macro itself.

     GLOBALVALUEREF (int, ss$_normal);
     GLOBALVALUEDEF (int, xyzzy,123);
     #ifdef __GNUC__
     #define ss$_normal ((int) ss$_normal)
     #define xyzzy ((int) xyzzy)
     #endif

   Don't use `globaldef' or `globalref' with a variable whose type is
an enumeration type; this is not implemented.  Instead, make the
variable an integer, and use a `globalvaluedef' for each of the
enumeration values.  An example of this would be:

     #ifdef __GNUC__
     GLOBALDEF (int, color, 0);
     GLOBALVALUEDEF (int, RED, 0);
     GLOBALVALUEDEF (int, BLUE, 1);
     GLOBALVALUEDEF (int, GREEN, 3);
     #else
     enum globaldef color {RED, BLUE, GREEN = 3};
     #endif


File: gcc.info,  Node: VMS Misc,  Prev: Global Declarations,  Up: VMS

Other VMS Issues
================

   GNU CC automatically arranges for `main' to return 1 by default if
you fail to specify an explicit return value.  This will be interpreted
by VMS as a status code indicating a normal successful completion. 
Version 1 of GNU CC did not provide this default.

   GNU CC on VMS works only with the GNU assembler, GAS.  You need
version 1.37 or later of GAS in order to produce value debugging
information for the VMS debugger.  Use the ordinary VMS linker with
the object files produced by GAS.

   Under previous versions of GNU CC, the generated code would
occasionally give strange results when linked to the sharable
`VAXCRTL' library.  Now this should work.

   A caveat for use of `const' global variables: the `const' modifier
must be specified in every external declaration of the variable in all
of the source files that use that variable.  Otherwise the linker will
issue warnings about conflicting attributes for the variable.  Your
program will still work despite the warnings, but the variable will be
placed in writable storage.

   The VMS linker does not distinguish between upper and lower case
letters in function and variable names.  However, usual practice in C
is to distinguish case.  Normally GNU CC (by means of the assembler
GAS) implements usual C behavior by augmenting each name that is not
all lower-case.  A name is augmented by truncating it to at most 23
characters and then adding more characters at the end which encode the
case pattern the rest.

   Name augmentation yields bad results for programs that use
precompiled libraries (such as Xlib) which were generated by another
compiler.  You can use the compiler option `/NOCASE_HACK' to inhibit
augmentation; it makes external C functions and variables
case-independent as is usual on VMS.  Alternatively, you could write
all references to the functions and variables in such libraries using
lower case; this will work on VMS, but is not portable to other
systems.

   Function and variable names are handled somewhat differently with
GNU C++.  The GNU C++ compiler performs "name mangling" on function
names, which means that it adds information to the function name to
describe the data types of the arguments that the function takes. One
result of this is that the name of a function can become very long. 
Since the VMS linker only recognizes the first 31 characters in a name,
special action is taken to ensure that each function and variable has a
unique name that can be represented in 31 characters.

   If the name (plus a name augmentation, if required) is less than 32
characters in length, then no special action is performed. If the name
is longer than 31 characters, the assembler (GAS) will generate a hash
string based upon the function name, truncate the function name to 23
characters, and append the hash string to the truncated name.  If the
`/VERBOSE' compiler option is used, the assembler will print both the
full and truncated names of each symbol that is truncated.

   The `/NOCASE_HACK' compiler option should not be used when you are
compiling programs that use libg++. libg++ has several instances of
objects (i.e.  `Filebuf' and `filebuf') which become indistinguishable
in a case-insensitive environment.  This leads to cases where you need
to inhibit augmentation selectively (if you were using libg++ and Xlib
in the same program, for example).  There is no special feature for
doing this, but you can get the result by defining a macro for each
mixed case symbol for which you wish to inhibit augmentation.  The
macro should expand into the lower case equivalent of itself.  For
example:

     #define StuDlyCapS studlycaps

   These macro definitions can be placed in a header file to minimize
the number of changes to your source code.


File: gcc.info,  Node: Portability,  Next: Interface,  Prev: VMS,  Up: Top

GNU CC and Portability
**********************

   The main goal of GNU CC was to make a good, fast compiler for
machines in the class that the GNU system aims to run on: 32-bit
machines that address 8-bit bytes and have several general registers. 
Elegance, theoretical power and simplicity are only secondary.

   GNU CC gets most of the information about the target machine from a
machine description which gives an algebraic formula for each of the
machine's instructions.  This is a very clean way to describe the
target.  But when the compiler needs information that is difficult to
express in this fashion, I have not hesitated to define an ad-hoc
parameter to the machine description.  The purpose of portability is
to reduce the total work needed on the compiler; it was not of
interest for its own sake.

   GNU CC does not contain machine dependent code, but it does contain
code that depends on machine parameters such as endianness (whether
the most significant byte has the highest or lowest address of the
bytes in a word) and the availability of autoincrement addressing.  In
the RTL-generation pass, it is often necessary to have multiple
strategies for generating code for a particular kind of syntax tree,
strategies that are usable for different combinations of parameters. 
Often I have not tried to address all possible cases, but only the
common ones or only the ones that I have encountered.  As a result, a
new target may require additional strategies.  You will know if this
happens because the compiler will call `abort'.  Fortunately, the new
strategies can be added in a machine-independent fashion, and will
affect only the target machines that need them.


File: gcc.info,  Node: Interface,  Next: Passes,  Prev: Portability,  Up: Top

Interfacing to GNU CC Output
****************************

   GNU CC is normally configured to use the same function calling
convention normally in use on the target system.  This is done with the
machine-description macros described (*note Target Macros::.).

   However, returning of structure and union values is done
differently on some target machines.  As a result, functions compiled
with PCC returning such types cannot be called from code compiled with
GNU CC, and vice versa.  This does not cause trouble often because few
Unix library routines return structures or unions.

   GNU CC code returns structures and unions that are 1, 2, 4 or 8
bytes long in the same registers used for `int' or `double' return
values.  (GNU CC typically allocates variables of such types in
registers also.)  Structures and unions of other sizes are returned by
storing them into an address passed by the caller (usually in a
register).  The machine-description macros `STRUCT_VALUE' and
`STRUCT_INCOMING_VALUE' tell GNU CC where to pass this address.

   By contrast, PCC on most target machines returns structures and
unions of any size by copying the data into an area of static storage,
and then returning the address of that storage as if it were a pointer
value.  The caller must copy the data from that memory area to the
place where the value is wanted.  This is slower than the method used
by GNU CC, and fails to be reentrant.

   On some target machines, such as RISC machines and the 80386, the
standard system convention is to pass to the subroutine the address of
where to return the value.  On these machines, GNU CC has been
configured to be compatible with the standard compiler, when this
method is used.  It may not be compatible for structures of 1, 2, 4 or
8 bytes.

   GNU CC uses the system's standard convention for passing arguments.
 On some machines, the first few arguments are passed in registers; in
others, all are passed on the stack.  It would be possible to use
registers for argument passing on any machine, and this would probably
result in a significant speedup.  But the result would be complete
incompatibility with code that follows the standard convention.  So
this change is practical only if you are switching to GNU CC as the
sole C compiler for the system.  We may implement register argument
passing on certain machines once we have a complete GNU system so that
we can compile the libraries with GNU CC.

   On some machines (particularly the Sparc), certain types of
arguments are passed "by invisible reference".  This means that the
value is stored in memory, and the address of the memory location is
passed to the subroutine.

   If you use `longjmp', beware of automatic variables.  ANSI C says
that automatic variables that are not declared `volatile' have
undefined values after a `longjmp'.  And this is all GNU CC promises
to do, because it is very difficult to restore register variables
correctly, and one of GNU CC's features is that it can put variables
in registers without your asking it to.

   If you want a variable to be unaltered by `longjmp', and you don't
want to write `volatile' because old C compilers don't accept it, just
take the address of the variable.  If a variable's address is ever
taken, even if just to compute it and ignore it, then the variable
cannot go in a register:

     {
       int careful;
       &careful;
       ...
     }

   Code compiled with GNU CC may call certain library routines.  Most
of them handle arithmetic for which there are no instructions.  This
includes multiply and divide on some machines, and floating point
operations on any machine for which floating point support is disabled
with `-msoft-float'.  Some standard parts of the C library, such as
`bcopy' or `memcpy', are also called automatically.  The usual
function call interface is used for calling the library routines.

   These library routines should be defined in the library `libgcc.a',
which GNU CC automatically searches whenever it links a program.  On
machines that have multiply and divide instructions, if hardware
floating point is in use, normally `libgcc.a' is not needed, but it is
searched just in case.

   Each arithmetic function is defined in `libgcc1.c' to use the
corresponding C arithmetic operator.  As long as the file is compiled
with another C compiler, which supports all the C arithmetic operators,
this file will work portably.  However, `libgcc1.c' does not work if
compiled with GNU CC, because each arithmetic function would compile
into a call to itself!

